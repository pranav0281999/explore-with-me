<!doctype html>
<html lang="en">
	<head>
		<title>XMasXP 2017</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

		<link rel="stylesheet" type="text/css" href="css/styles.css" media="screen" />
		<link href="https://fonts.googleapis.com/css?family=Roboto|Roboto+Slab" rel="stylesheet">

	</head>
	<body>

		<div id="container"></div>
		<div id="info" >
			<p><a href="../n" >Previous</a> | <a href="../n" >Next</a></p>
			<h1>XMasXP 2017</h1>
			<p>Lorem ipsum</p>
			<p id="moreDetails"><b>More details...</b></p>
		</div>
		<div id="details" class="hidden">
			<div class="content" >
				<h1>Details</h1>
				<p>Lorem ipsum <a href="#" >dolor sit amet</a>.</p>
				<a href="#" id="close-details">Close</a>
			</div>
		</div>

		<script src="js/Common.js"></script>
		<script src="js/three.min.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script src="js/perlin.js"></script>
		<script src="js/Maf.js"></script>

<script>

'use strict';

var container, renderer, camera, controls, scene;
var mesh;

var helper;

var container = document.getElementById( 'container' );

function noiseFunc( v ){

	var s  = noise.simplex3( v.x, v.y, v.z );
	var s1 = noise.simplex3( v.y - 19.1, v.z + 33.4, v.x + 47.2 );
	var s2 = noise.simplex3( v.z + 74.2, v.x - 124.5, v.y + 99.4 );
	return new THREE.Vector3( s , s1 , s2 );

}

function noiseFunc2D( vx, vy ){

	var s  = noise.simplex2( vx, vy );
	var s1 = noise.simplex2( vy - 19.1, vy + 33.4 );
	return new THREE.Vector2( s, s1 );

}

var e = .1;
var dx = new THREE.Vector3( e   , 0.0 , 0.0 );
var dy = new THREE.Vector3( 0.0 , e   , 0.0 );
var dz = new THREE.Vector3( 0.0 , 0.0 , e   );
var dx2D = new THREE.Vector2( e   , 0.0 );
var dy2D = new THREE.Vector2( 0.0 , e   );

var tmp = new THREE.Vector3();
var res = new THREE.Vector3();
var tmp2D = new THREE.Vector2();
var res2D = new THREE.Vector2();

var orthoQuad, orthoCamera, orthoScene;
var baseFBO, depthFBO, blurFBO;
var resolution = new THREE.Vector2();
var combineShader, volumeShader, blurShader, assembleShader;

function curl( p ){

	var p_x0 = noiseFunc( tmp.copy( p ).sub( dx ) );
	var p_x1 = noiseFunc( tmp.copy( p ).add( dx ) );
	var p_y0 = noiseFunc( tmp.copy( p ).sub( dy ) );
	var p_y1 = noiseFunc( tmp.copy( p ).add( dy ) );
	var p_z0 = noiseFunc( tmp.copy( p ).sub( dz ) );
	var p_z1 = noiseFunc( tmp.copy( p ).add( dz ) );

	var x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;
	var y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;
	var z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;

	var divisor = 1.0 / ( 2.0 * e );
	res.set( x, y, z ).multiplyScalar( divisor ).normalize();
	return res;

}

function curl2D( p ){

	var p_x0 = noiseFunc2D( p.x - e, p.y );
	var p_x1 = noiseFunc2D( p.x + e, p.y );
	var p_y0 = noiseFunc2D( p.x, p.y - e );
	var p_y1 = noiseFunc2D( p.x, p.y + e );

	var x = p_y1.y - p_y0.y;
	var y = p_x1.x + p_x0.x;

	var divisor = 1.0 / ( 2.0 * e );
	res2D.set( x, y ).multiplyScalar( divisor ).normalize();
	return res2D;

}

function addCurve( origin, length ) {

	var points = length;

	var p = new THREE.Vector2();
	var vertices = [];

	p.set( origin.x, origin.y );
	for( var j = 0, ptr = 0; j < points; j++, ptr += 3 ) {

		p.add( curl2D(p.clone().multiplyScalar(.2)).multiplyScalar(.4));

		vertices.push( new THREE.Vector3(p.x,map(p.x+100,p.y+100)* 10 - 5.,p.y) );

	}

	var path = new THREE.CatmullRomCurve3(vertices);
	var r = Maf.randomInRange( .04, .06 );
	var geometry = new THREE.TubeGeometry( path, points, .01, 3, false );

	return geometry;

}

function squareTurbulence(v) {
	return Math.pow(v,2.);
}

function ridgedTurbulence(v) {
	return 1. - Math.abs(v);
}

function fbm(u,v) {
	var value = 0.;
	var amplitude = 1.;
	for ( var i = 0; i < 8; i++) {
	    value += amplitude * Math.abs(noise.simplex2(u,v));
	    u *= 2.;
	    v *= 2.;
	    amplitude *= .5;
	}
	return value;
}

function map( u,v ) {
	u *= .01;
	v *= .01;
	u = .1 * fbm(u,v);
	v = .1 * fbm(u,v);
	var n = ridgedTurbulence(fbm(.1*u,.1*v));
	n += ridgedTurbulence(fbm(.01*u,.01*v));
	n += squareTurbulence(fbm(.1*u,.1*v));
    n += noise.simplex2( u, v );
    return n;
}

function initScene() {

	var planeMaterial = new THREE.MeshBasicMaterial({
		color: 0xff00ff,
		transparent: !true,
		opacity: .1,
		wireframe: !true,
		side: THREE.DoubleSide
	});

	var geometry = new THREE.PlaneBufferGeometry(100,100,200,200);

	var tmpVector = new THREE.Vector3();
	for( var j = 0; j < geometry.attributes.position.array.length; j += 3 ) {
		var x = geometry.attributes.position.array[ j + 0 ];
		var y = geometry.attributes.position.array[ j + 1 ];
		var z = geometry.attributes.position.array[ j + 2 ];
		var h = map( x + 100,y + 100 );
		geometry.attributes.position.array[ j + 0 ] = x;
		geometry.attributes.position.array[ j + 1 ] = -.1 + h * 10 - 5;
		geometry.attributes.position.array[ j + 2 ] = y;
	}

	var plane = new THREE.Mesh( geometry, planeMaterial );
	scene.add( plane );

	var material = new THREE.MeshBasicMaterial({
		color: 0xffffff,
	});

	var geometries = [];
	var pos = new THREE.Vector3( 0, 0, 0 );
	var range = 50;
	var step = 2;
	for( var y =-50 ; y < 50; y+=step ) {
		for( var x =-50 ; x < 50; x+=step ) {
			var pos = new THREE.Vector2( x,y );
			var line = addCurve( pos, 100 );
			geometries.push( new THREE.BufferGeometry().fromGeometry( line ) );
		}
	}

	var count = 0;
	geometries.forEach( function( g ) { count += g.attributes.position.count; } );

	var geometry = new THREE.BufferGeometry();

	geometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( count * 3 ), 3 ) );
	geometry.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( count * 3 ), 3 ) );
	geometry.addAttribute( 'uv', new THREE.BufferAttribute( new Float32Array( count * 2 ), 2 ) );

	var ptr = 0;
	geometries.forEach( function( g ) {

		geometry.merge( g, ptr );
		ptr += g.attributes.position.count;

	})

	//geometry.center();
	mesh = new THREE.Mesh( geometry, material );
	mesh.castShadow = true;
	mesh.receiveShadow = true;
	scene.add( mesh );

}

function init() {

	container = document.getElementById( 'container' );

	scene = new THREE.Scene();

	camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, .1, 10000 );
	camera.target = new THREE.Vector3( 0, 0, 0 );
	camera.position.set( 200,200,200 );
	camera.lookAt( camera.target );
	scene.add( camera );

	renderer = new THREE.WebGLRenderer( { antialias: true, preserveDrawingBuffer: true } );
	renderer.setPixelRatio( window.devicePixelRatio );
	renderer.setClearColor( 0x261b1f, 1 );
	container.appendChild( renderer.domElement );

	addCommonUI(renderer.domElement);

	renderer.shadowMap.enabled = true;
	renderer.shadowMap.type = THREE.PCFShadowMap;

	controls = new THREE.OrbitControls( camera, renderer.domElement );

	initScene();
	onWindowResized();

	window.addEventListener( 'resize', onWindowResized );

	animate();

}

function onWindowResized( event ) {

	var w = container.clientWidth;
	var h = container.clientHeight;

	renderer.setSize( w, h );
	camera.aspect = w / h;
	camera.updateProjectionMatrix();

}

function animate() {

	requestAnimationFrame( animate );

	controls.update();

	renderer.render( scene, camera );

}

window.addEventListener( 'load', init );

</script>

	</body>
</html>
